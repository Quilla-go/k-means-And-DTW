## k-means-And-DTW原理及算法介绍 Chapter02

[toc]

`DTW`距离代码在文件中是：

```python
# `DTW`距离，时间复杂度为两个时间序列长度相乘
def DTWDistance(s1, s2):
```

这样的计算全量代价太大，时间复杂度比较高，所以需要进行优化。

最简单的约束条件之一是不允许翘曲路径偏离母体对角线很远的距离[^3]。 在此约束下，路径允许从对角线徘徊的距离限制为一个指定 `sizer` 的窗口（也称为`Sakoe-Chibaband`），它是一个参数，这里设为`W`。

这种窗口约束不仅加快了 `DTW` 的计算速度，而且在某种程度上还提高了时间序列分类的准确性[^4]。 

下文及代码中将这种窗口大小受约束的 `DTW` 称为 `DTW-W`，并将基于 `DTW-W` 的单近邻方法称为`k-mean-DTW-W`。 

应该注意的是，当窗口大小参数设置为零时，矩阵中唯一可能的弯曲路径就是对角线本身，在这种情况下，`DTW-W` 退化到欧几里得距离。

只检测前`W`个窗口的值。优化后的`DTW-W`距离在文件中的函数名是：

```python
# DTW_W距离, 优化后的算法，只检测前W个窗口的值
def DTWDistance_W(s1, s2, w):
```

后面的计算就用优化后的 `DTW_Distance_W()` 函数。



### 四、结果

定义了分成两类的情形，可以根据num_clust 的值进行灵活的调整，等于2是的分类和图示情况如下：

![](https://img2018.cnblogs.com/blog/1704791/202003/1704791-20200315235705995-152189259.png)

WBC01：[6774, 7193, 8070, 8108, 8195, 2020006799, 2020007003, 2020007251, 2020007420, 2020007636, 2020007718, 2020007928, 2020007934, 2020008022, 2020008196, 2020008239, 2020008302, 2020008354, 2020008418, 2020008513, 2020008535, 2020008737, 2020008890, 2020008909, 2020009042, 2020009043, 2020009050, 2020009201, 2020009213, 2020009289, 2020009420, 2020009557]

WBC02：[2020007250, 2020007388, 2020007389, 2020007422, 2020007625, 2020007703, 2020007927, 2020009049, 2020009158, 2020009284, 2020009580]

说明：
代码训练过程中，一定要注意数据类型，比如`matrix`和`ndarray`，虽然打印的时候都是`（45，30）`，但是再训练的时候，稍加不注意，就会导致乱七八糟的问题，需要排查好久。

本文的数据和代码，请登录：my github，进行下载。若是对您有用，请不吝给颗星。

具体请看博文：https://www.cnblogs.com/yifanrensheng/p/12501238.html